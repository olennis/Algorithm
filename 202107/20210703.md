# 로또의 최고 순위와 최저순위

### **문제 설명**

`로또 6/45`(이하 '로또'로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. [1](https://programmers.co.kr/learn/courses/30/lessons/77484#fn1)

[제목 없음](https://www.notion.so/465d3f227c034481bdd8f6a23d01cd92)

로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.알아볼 수 없는 번호를 `0`으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 `44, 1, 0, 0, 31 25`라고 가정해보겠습니다. 당첨 번호 6개가 `31, 10, 45, 1, 6, 19`라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다.

[제목 없음](https://www.notion.so/282e1b01487e4e3f8ccd1ea762d60b07)

- 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.
- 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.
  - 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.
- 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.
  - 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.

민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- lottos는 길이 6인 정수 배열입니다.
- lottos의 모든 원소는 0 이상 45 이하인 정수입니다.
  - 0은 알아볼 수 없는 숫자를 의미합니다.
  - 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.
  - lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.
- win_nums은 길이 6인 정수 배열입니다.
- win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.
  - win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.
  - win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.

---

### 입출력 예

| lottos                | win_nums                 | result |
| --------------------- | ------------------------ | ------ |
| [44, 1, 0, 0, 31, 25] | [31, 10, 45, 1, 6, 19]   | [3, 5] |
| [0, 0, 0, 0, 0, 0]    | [38, 19, 20, 40, 15, 25] | [1, 6] |
| [45, 4, 35, 20, 3, 9] | [20, 9, 3, 45, 4, 35]    | [1, 1] |

### 입출력 예 설명

입출력 예 #1문제 예시와 같습니다.

입출력 예 #2알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다.

입출력 예 #3민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다.

### 코드

```jsx
function solution(lottos, win_nums) {
  var rank = { 6: 1, 5: 2, 4: 3, 3: 4, 2: 5 };
  var max;
  var correctNum = lottos.filter((lotto) => win_nums.includes(lotto)).length;
  var zeroNum = lottos.filter((lotto) => lotto === 0).length;
  if (zeroNum === 0) {
    if (correctNum === 0) {
      return [6, 6];
    }
    return [rank[correctNum], rank[correctNum]];
  } else {
    if (!rank[correctNum + zeroNum]) {
      return [6, rank[correctNum]];
    } else if (!rank[correctNum]) {
      return [rank[correctNum + zeroNum], 6];
    } else {
      return [rank[correctNum + zeroNum], rank[correctNum]];
    }
  }
}
```

rank를 선언할 때, 굳이 객체로 선언하지 않고 [6,6,5,4,3,2,1]과 같은 식으로 인덱스를 활용해서 선언한 후 활용하는 것도 좋을 뻔했다. 객체로 선언했기 때문에 오히려 더 복잡한 코드가 나오게 됐다. 배열을 너무 활용한다고 억지로 배열을 배제하는것이 아니라 배열이 필요할 때는 배열을 통해, 객체가 필요할 때는 객체를 사용하는 안목이 필요하지 않을까..?

그 외에는 correctNum과 zeroNum을 잘 걸러 낸 것 같고, 이 두개의 변수를 통해 조건문을 성립시켰다. 조건문이 좀 생각보다 많은 뎁스를 가지게 되었지만.. 다른 사람들이 푼 것을 봐도 조건문이 어느정도는 들어가기 때문에 객체가 아닌 배열로 하게 된다면 조금 더 간결한 코드가 될 수 있을 것 같다.
